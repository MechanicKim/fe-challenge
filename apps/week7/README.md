# 7주차 챌린지 가이드: 실시간 협업 화이트보드 (드로잉) 개발

7주차 챌린지는 **그래픽 렌더링**과 **실시간 통신**을 결합한 고도의 실무 과제입니다. 사용자들이 캔버스 위에서 그림을 그리고, 그 내용이 다른 사용자에게 **실시간으로 공유**되는 화이트보드 애플리케이션의 핵심 기능을 구현합니다.

이 챌린지에서는 **Node.js 서버와 WebSocket**을 사용하여 실제 서버 환경에서의 실시간 동기화를 구현하는 것을 최우선으로 권장합니다.

### 🚀 챌린지 개요: 목표와 요구사항

| 카테고리 | 상세 목표 |
| --- | --- |
| **핵심 기능** | 마우스 움직임에 따라 캔버스 위에 선을 그릴 수 있어야 하며, 그려진 **선 데이터**가 서버를 통해 **다른 사용자에게 즉시 공유**되어 렌더링되어야 합니다. |
| **주요 기술** | **프레임워크** (React/Vue/Svelte), **HTML Canvas API**, **Node.js + WebSocket (Socket.io 등)**. |
| **데이터 관리** | 드로잉 데이터를 효율적으로 구조화하여 저장하고 브로드캐스팅해야 합니다. |
| **UI/UX** | 캔버스가 부모 요소에 맞게 **반응형**으로 크기가 조정되어야 하며, 드로잉 툴(색상, 두께) 선택 기능이 필요합니다. |

### ⚙️ 필수 구현 단계

### 1. 서버 및 클라이언트 통신 준비

1. **Node.js 서버 설정:** Express 등 Node.js 프레임워크를 사용하여 서버를 설정하고, `ws` 또는 `Socket.io` 같은 라이브러리를 설치하여 **WebSocket 서버**를 엽니다.
2. **클라이언트 WebSocket 연결:** 프론트엔드 코드에서 서버의 WebSocket 엔드포인트에 연결합니다.
3. **데이터 구조:** 각 드로잉 선(Line)을 하나의 객체로 관리합니다. 각 객체는 **시작 시간, 사용자 ID, 색상, 두께, 그리고 좌표 배열** (`[{x, y}, {x, y}, ...]`)을 포함해야 합니다.

### 2. 로컬 드로잉 기능 (Canvas API)

1. **캔버스 컴포넌트:** `<canvas>` 요소를 포함하는 컴포넌트를 생성하고, 2D 컨텍스트를 초기화합니다.
2. **마우스 이벤트:** `mousedown`, `mousemove`, `mouseup` 이벤트를 캔버스에 등록합니다.
3. **드로잉 로직:** 마우스 이동 시 이전 좌표에서 현재 좌표까지 선을 그립니다. **선 데이터**는 메모리(컴포넌트 상태)에 저장합니다.
4. **반응형 캔버스:** 부모 요소의 크기에 맞춰 캔버스의 해상도와 뷰포트가 자동으로 조정되도록 `resize` 이벤트를 처리합니다.

### 3. 실시간 동기화 (WebSocket) (핵심)

1. **데이터 전송:** `mouseup` 이벤트 발생 시 (하나의 선 그리기 세션 완료), 해당 선의 데이터 전체를 WebSocket을 통해 **서버로 전송**합니다.
2. **서버 브로드캐스팅:** 서버는 데이터를 수신한 후, **데이터를 보낸 클라이언트를 제외한** 모든 연결된 클라이언트에게 해당 데이터를 즉시 **브로드캐스팅**합니다.
3. **클라이언트 수신 및 렌더링:**
    - 클라이언트는 WebSocket 메시지를 수신하면, 그 데이터(다른 사용자의 드로잉)를 파싱합니다.
    - 수신된 데이터를 캔버스에 렌더링하여 **실시간 동기화**를 구현합니다.

### 4. 드로잉 툴 및 UI

1. **색상 및 두께:** 드로잉에 사용할 색상(Color Picker)과 선 두께(Slider)를 선택할 수 있는 UI를 구현합니다.
2. **초기 상태:** 클라이언트가 접속할 때, **서버에 저장된 기존 드로잉 전체**를 로드하여 캔버스에 렌더링합니다.

### 🌟 심화 도전 과제 (Challenge Up)

실력을 최상으로 올리고 싶다면 다음 항목에 도전해 보세요.

1. **되돌리기(Undo) 기능:** `Undo` 액션을 서버로 전송하고, 서버는 마지막 선을 데이터에서 삭제한 후 **모든 클라이언트에게 전체 캔버스를 재렌더링**하도록 명령합니다.
2. **WebRTC 고려:** 낮은 레이턴시(Latency)가 중요한 환경에서는 WebSocket 대신 **WebRTC Data Channel**을 고려하여 프로토콜의 장단점을 논의해 보세요.
3. **성능 최적화:** `mousemove` 이벤트 발생 시 서버로 데이터를 전송하는 빈도를 `throttle` 함수를 사용하여 제한합니다.
